#!/usr/bin/env ruby
require 'optparse'
require 'HTTParty'
require 'rails'
require 'json'
class Rule
  attr_reader :impact, :name, :suggestion
  def initialize(opts)
    @impact      = opts['ruleImpact'].to_f
    @name        = opts['localizedRuleName']
    @suggestion  = Suggestion.new(opts['urlBlocks'])
  end

  def to_s(with_suggestion=false)
    ret = "#{'%.2f' % impact}: #{name}"
    ret << "\n" << suggestion.to_s
    ret
  end

end

class Stats
  attr_reader :total_resources, :hosts, :static_resources, :js_resources, :css_resources, :other_bytes,
              :request_bytes, :html_bytes, :css_bytes, :image_bytes, :js_bytes, :flash_bytes, :text_bytes

  def initialize(h)
    h.default = ''
    @total_resources  = h['numberResources']
    @hosts            = h['numberHosts']
    @static_resources = h['numberStaticResources']
    @js_resources     = h['numberJsResources']
    @css_resources    = h['numberCssResources']
    @request_bytes    = h['totalRequestBytes'].to_i
    @html_bytes       = h['htmlResponseBytes'].to_i
    @css_bytes        = h['cssResponseBytes'].to_i
    @image_bytes      = h['imageResponseBytes'].to_i
    @js_bytes         = h['javascriptResponseBytes'].to_i
    @text_bytes       = h['textResponseBytes'].to_i
    @flash_bytes      = h['flashResponseBytes'].to_i
    @js_bytes         = h['javascriptResponseBytes'].to_i
    @other_bytes      = h['otherResponseBytes'].to_i
  end

  def to_s
<<-EOS
  Hosts:     #{hosts}
  Requests:  #{request_bytes / 1024}kB
  Resources: #{total_resources} (#{static_resources} static)
     JS      : #{js_resources}, #{js_bytes / 1024}kB
     CSS     : #{css_resources}, #{css_bytes / 1024}kB
     HTML    : #{html_bytes / 1024}kB
     Images  : #{image_bytes / 1024}kB
EOS
  end

  def to_h
    arr = %i(total_resources hosts static_resources js_resources css_resources
             total_bytes html_bytes css_bytes image_bytes js_bytes)
    Hash[arr.zip(arr.map {|m| send m})]
  end
end

class Suggestion
  attr_reader :bottom_line, :more_info_at, :recommendations
  def initialize(arr)
    @recommendations = []
    base_info_from(arr.shift['header'])
    more_info_from(arr.shift) unless arr.empty?
    arr.each do |h|
      if h.has_key?('header')
        base_info_from h
      else
        more_info_from h
      end
    end
  end

  def to_s
    ret = bottom_line.to_s << "\n"
    ret << "More information at #{more_info_at}\n" unless more_info_at.blank?
    ret << recommendations.join("   |   ")
    ret
  end
  private

  def base_info_from(hash)
    @bottom_line  = hash['format']
    if hash.has_key?('args')
      @more_info_at = hash['args'].first['value'] if hash['args'].first['type'] == 'HYPERLINK'
    end
  end

  def more_info_from(hash)
    return unless hash.has_key?('urls')
    urls = hash.delete('urls')
    urls.each do |u|
      @recommendations.push sub_in(u['result'])
    end
    nil
  end

  # Returns string with substitutions made
  def sub_in(hash)
    return hash['format'] unless hash.has_key?('args')
    args = hash['args'].map {|h| h['value']}
    hash['format'].gsub(/(?:\$)(\d)/) { |match| args[match.delete('$').to_i - 1] }
  end

end

class SlowPage
  API_URL='https://www.googleapis.com/pagespeedonline/v1/runPagespeed'
  attr_reader :url, :strategy, :rule_results, :stats, :score, :verbose
  def initialize(opts)
    @url          = opts[:url]
    @verbose      = opts[:verbose]
    @url          = "http://#{@url}" unless @url =~ /^https?:\/\//
    @api_key      = opts[:key]
    @strategy     = opts[:strategy]
    @score        = hash['score']
    @stats        = Stats.new(hash['pageStats'])
    @rule_results = rules_from hash['formattedResults']['ruleResults']
  end

  def to_s
    ret = "#{url} (using #{strategy} strategy)\n"
    ret << "Score: #{score}\n"
    ret << "#{stats.to_s}"
    ret << "#{formatted_rule_results}"
    ret
  end

  def formatted_rule_results
    @rule_results.each {|r| r.to_s(verbose)}.join("\n")
  end

  def response
    @response ||= request_from_api
  end

  attr_reader :api_key

  def request_from_api
    opts_hash = {
      query: {
        key: api_key,
        url: url,
        prettyPrint: true,
        strategy: strategy
      }
    }
    HTTParty.get(API_URL, opts_hash)
  end

  def body
    response.body
  end

  def hash
    JSON.parse(body)
  end

  def rules_from(input_hash)
    ret_rules = input_hash.map do |k, rule_hash|
      Rule.new(rule_hash)
    end
    ret_rules.select! {|rule| rule.impact > 0.0 }
    ret_rules.sort! {|a,b| b.impact <=> a.impact }
  end
end

DEFAULT_KEY_LOCATION='~/.googleapi.secret'

def key_from(file)
  (File.read File.expand_path(file)).chomp
end

def opts_from_cli
  options = {}
  opt_parser = OptionParser.new do |opts|
    opts.banner = "#{$0} [options] url"

    options[:verbose] = false
    opts.on('-v', '--verbose', 'Display more information') { options[:verbose] = true }

    options[:key] = nil
    opts.on('-f FILE', '--file FILE', 'File containing Google API key') do |file|
      begin
        options[:key] = key_from(file)
      rescue
        puts "Could not open #{file}"
        exit
      end
    end
    options[:key] = key_from(DEFAULT_KEY_LOCATION) if (options[:key].blank?)
    opts.on('-k KEY', '--key KEY', 'Google API key') { |key| options[:key] = key }
    options[:strategy] = 'desktop'
    opts.on('-s STRATEGY', '--strategy STRATEGY', 'Strategy: <desktop|mobile>') { |strat| options[:strategy] = strat if strat == 'mobile' }
    opts.on('-h', '--help', 'Display this screen') { puts opts ; exit }
  end

  opt_parser.parse!
  options[:url] = ARGV.pop
  abort opt_parser.to_s if options[:url].blank?
  options
end

options = opts_from_cli
slowpage = SlowPage.new(options)
puts slowpage.to_s
